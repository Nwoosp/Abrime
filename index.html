<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ramo dibujado — Flores amarillas</title>
<style>
  :root{
    --bg:#faf7f2;
    --paper:#ffffff;
    --accent:#f2c200;
    --text:#2b2312;
  }
  html,body{height:100%}
  body{
    margin:0;
    min-height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    background:linear-gradient(180deg,#fffaf0 0%, #fff3d8 60%, #fce9b8 100%);
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    color:var(--text);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    padding:18px;
  }

  .card{
    width:min(980px, 98vw);
    max-width:1100px;
    height:min(760px, 92vh);
    background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.85));
    border-radius:18px;
    box-shadow: 0 18px 50px rgba(36,30,20,0.14), 0 3px 8px rgba(0,0,0,0.05);
    padding:18px;
    position:relative;
    overflow:hidden;
  }

  .title {
    position:absolute;
    left:22px;
    top:18px;
    right:22px;
    pointer-events:none;
    text-align:center;
  }
  .title h1{
    margin:0;
    font-size:1.15rem;
    font-weight:700;
    color:var(--text);
    letter-spacing:0.2px;
    background: linear-gradient(180deg, rgba(255,255,255,0.4), rgba(255,255,255,0.2));
    display:inline-block;
    padding:10px 16px;
    border-radius:12px;
    box-shadow: 0 4px 10px rgba(0,0,0,0.06);
  }

  .canvas-wrap{
    width:100%;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  /* small responsive tweak */
  @media (max-width:560px){
    .card{ padding:10px; border-radius:12px; }
    .title h1{ font-size:0.95rem; padding:8px 12px; }
  }

  /* subtle footer note */
  .footer{
    position:absolute;
    left:14px;
    bottom:10px;
    font-size:.82rem;
    color:#6b5f4a;
    opacity:.9;
  }

  /* share button (optional) */
  .share{
    position:absolute;
    right:14px;
    bottom:10px;
    display:inline-flex;
    gap:8px;
  }
  .btn{
    background:#ffd54a;
    border:0;
    padding:8px 12px;
    border-radius:10px;
    font-weight:600;
    cursor:pointer;
    box-shadow:0 8px 18px rgba(0,0,0,0.12);
  }
</style>
</head>
<body>
  <div class="card" role="main" aria-label="Ramo dibujado de flores amarillas">
    <div class="title" aria-hidden="false">
      <!-- La frase que pediste queda aquí -->
      <h1 id="phrase">Aunque este muy lejos, a mi manera quería regalarte flores amor</h1>
    </div>

    <div class="canvas-wrap">
      <!-- SVG generado por JS -->
      <svg id="svg" viewBox="0 0 1100 820" width="100%" height="100%" preserveAspectRatio="xMidYMid meet" role="img" aria-label="Ramo de rosas amarillas dibujado"></svg>
    </div>

    <div class="footer">Ramo generado con SVG • seed fijo para reproducibilidad</div>

    <div class="share">
      <button id="copyLink" class="btn" title="Copiar link con frase y seed">Copiar link</button>
    </div>
  </div>

<script>
/*
  Ramo de rosas amarillas (SVG)
  - Semilla fija para reproducir exactamente el mismo ramo.
  - Genera muchas "rosas" compuestas por capas de pétalos.
  - Añade papel de envoltorio y un moño.
*/

const svg = document.getElementById('svg');
const params = new URLSearchParams(location.search);
const userMsg = params.get('msg') || document.getElementById('phrase').textContent;
const seed = Number(params.get('seed')) || 20250401; // seed fijo si no se pasa
document.getElementById('phrase').textContent = decodeURIComponent(userMsg);

// Deterministic PRNG (mulberry32)
function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; } }
const rnd = mulberry32(seed);

// Helpers
function C(tag){ return document.createElementNS('http://www.w3.org/2000/svg', tag); }
function R(min, max){ return min + (max-min) * rnd(); }
function RI(min,max){ return Math.floor(R(min, max+1)); }

// Setup defs: gradients, filters
const defs = C('defs');

// shadow filter
defs.innerHTML += `
  <filter id="softShadow" x="-50%" y="-50%" width="200%" height="200%">
    <feGaussianBlur in="SourceAlpha" stdDeviation="6" result="b"/>
    <feOffset in="b" dx="0" dy="6" result="o"/>
    <feComponentTransfer in="o"><feFuncA type="linear" slope="0.45"/></feComponentTransfer>
    <feMerge><feMergeNode in="o"/><feMergeNode in="SourceGraphic"/></feMerge>
  </filter>
`;

// petal gradient family (three variants for subtle variety)
function petalGrad(id, hueShift = 0){
  return `<radialGradient id="${id}" cx="45%" cy="35%" r="80%">
    <stop offset="0%" stop-color="hsl(${48 + hueShift} 98% 92%)"/>
    <stop offset="45%" stop-color="hsl(${48 + hueShift} 92% 70%)"/>
    <stop offset="100%" stop-color="hsl(${42 + hueShift} 95% 48%)"/>
  </radialGradient>`;
}
defs.innerHTML += petalGrad('petalA', 0);
defs.innerHTML += petalGrad('petalB', -6);
defs.innerHTML += petalGrad('petalC', 7);

// center of rose
defs.innerHTML += `
  <radialGradient id="centerG" cx="50%" cy="50%" r="60%">
    <stop offset="0%" stop-color="#6a4400"/>
    <stop offset="45%" stop-color="#9a650a"/>
    <stop offset="100%" stop-color="#331f00"/>
  </radialGradient>
`;

// paper gradient
defs.innerHTML += `
  <linearGradient id="paperG" x1="0" y1="0" x2="1" y2="1">
    <stop offset="0%" stop-color="#ffffff"/>
    <stop offset="100%" stop-color="#f3f3f3"/>
  </linearGradient>
`;

// ribbon gradient
defs.innerHTML += `
  <linearGradient id="ribbonG" x1="0" y1="0" x2="1" y2="1">
    <stop offset="0%" stop-color="#fff6e0"/>
    <stop offset="60%" stop-color="#ffd24a"/>
    <stop offset="100%" stop-color="#ffb800"/>
  </linearGradient>
`;

// subtle texture overlay (very light)
defs.innerHTML += `
  <filter id="grain" x="0" y="0" width="100%" height="100%">
    <feTurbulence baseFrequency="0.9" numOctaves="2" stitchTiles="stitch" result="noise"/>
    <feColorMatrix type="saturate" values="0"/>
    <feComponentTransfer><feFuncA type="table" tableValues="0 0.02"/></feComponentTransfer>
    <feBlend mode="multiply" in2="SourceGraphic"/>
  </filter>
`;

svg.appendChild(defs);

// background rect for subtle vignette
const bg = C('rect');
bg.setAttribute('x',0); bg.setAttribute('y',0); bg.setAttribute('width',1100); bg.setAttribute('height',820);
bg.setAttribute('fill','none');
svg.appendChild(bg);

// Root group
const root = C('g');
svg.appendChild(root);

// Draw wrapping paper (big triangular shapes behind flowers)
function drawPaper(){
  const paper = C('g');
  paper.setAttribute('transform', 'translate(0 40)');
  // left sheet
  const left = C('path');
  left.setAttribute('d', 'M 160 420 L 520 120 L 580 160 L 240 480 Z');
  left.setAttribute('fill','url(#paperG)');
  left.setAttribute('stroke','rgba(200,200,200,0.15)');
  left.setAttribute('stroke-width','1');
  left.setAttribute('filter','url(#softShadow)');
  left.setAttribute('opacity','0.98');
  paper.appendChild(left);
  // right sheet
  const right = C('path');
  right.setAttribute('d', 'M 940 420 L 580 120 L 520 160 L 880 480 Z');
  right.setAttribute('fill','url(#paperG)');
  right.setAttribute('stroke','rgba(200,200,200,0.15)');
  right.setAttribute('stroke-width','1');
  right.setAttribute('filter','url(#softShadow)');
  right.setAttribute('opacity','0.98');
  paper.appendChild(right);

  // inner white layer to mimic translucent wrapping
  const inner = C('path');
  inner.setAttribute('d', 'M 220 420 L 550 160 L 550 140 L 500 200 L 260 480 Z');
  inner.setAttribute('fill','rgba(255,255,255,0.65)');
  inner.setAttribute('opacity','0.95');
  paper.appendChild(inner);
  root.appendChild(paper);
}
drawPaper();

// Draw stems peeking out bottom
function drawStems(){
  const stems = C('g');
  stems.setAttribute('transform','translate(0 36)');
  for(let i=0;i<6;i++){
    const x = 600 + (i-2.5) * 10 + R(-6,6);
    const path = C('path');
    const ctrlX = x + R(-30,40);
    const d = `M ${x} 540 C ${ctrlX} ${R(560,640)} ${ctrlX+10} ${R(700,760)} ${x+4} 780`;
    path.setAttribute('d', d);
    path.setAttribute('stroke','#2f7a2f');
    path.setAttribute('stroke-width', R(6,9));
    path.setAttribute('stroke-linecap','round');
    path.setAttribute('fill','none');
    path.setAttribute('opacity',0.95);
    stems.appendChild(path);
  }
  root.appendChild(stems);
}
drawStems();

// Draw bow/ribbon at front
function drawBow(){
  const bow = C('g');
  bow.setAttribute('transform','translate(0 0)');
  // knot
  const knot = C('ellipse');
  knot.setAttribute('cx',620); knot.setAttribute('cy',480);
  knot.setAttribute('rx',38); knot.setAttribute('ry',26);
  knot.setAttribute('fill','url(#ribbonG)');
  knot.setAttribute('filter','url(#softShadow)');
  bow.appendChild(knot);
  // left loop
  const leftLoop = C('path');
  leftLoop.setAttribute('d', 'M 610 480 C 520 420 520 560 620 510');
  leftLoop.setAttribute('stroke','url(#ribbonG)');
  leftLoop.setAttribute('stroke-width','24');
  leftLoop.setAttribute('stroke-linecap','round');
  leftLoop.setAttribute('fill','none');
  leftLoop.setAttribute('opacity','0.98');
  bow.appendChild(leftLoop);
  // right loop
  const rightLoop = C('path');
  rightLoop.setAttribute('d', 'M 630 480 C 740 420 740 560 640 510');
  rightLoop.setAttribute('stroke','url(#ribbonG)');
  rightLoop.setAttribute('stroke-width','24');
  rightLoop.setAttribute('stroke-linecap','round');
  rightLoop.setAttribute('fill','none');
  rightLoop.setAttribute('opacity','0.98');
  bow.appendChild(rightLoop);
  // tails
  const tailL = C('path');
  tailL.setAttribute('d','M 590 500 C 560 560 540 620 520 720');
  tailL.setAttribute('stroke','#ffb400');
  tailL.setAttribute('stroke-width','14');
  tailL.setAttribute('stroke-linecap','round');
  tailL.setAttribute('fill','none');
  tailL.setAttribute('opacity','0.95');
  bow.appendChild(tailL);
  const tailR = C('path');
  tailR.setAttribute('d','M 650 500 C 680 560 700 620 730 720');
  tailR.setAttribute('stroke','#ffb400');
  tailR.setAttribute('stroke-width','14');
  tailR.setAttribute('stroke-linecap','round');
  tailR.setAttribute('fill','none');
  tailR.setAttribute('opacity','0.95');
  bow.appendChild(tailR);
  root.appendChild(bow);
}

// Helper to draw a single rose around (cx,cy)
function makeRose(cx, cy, scale=1, rotation=0, variant=0){
  const g = C('g');
  g.setAttribute('transform', `translate(${cx} ${cy}) scale(${scale}) rotate(${rotation})`);
  // petals as layered paths (spiral-like)
  const layers = RI(5,8); // number of layers
  for(let l=layers; l>=1; l--){
    const petals = Math.max(6, Math.floor(6 + l*1.5 + R(-1,2)));
    const layerR = 6 + l * 6.2 + R(-1.4, 1.6);
    const width = 8 + l*3.6 + R(-1.8, 2.2);
    const hueShift = variant * 3 + (l%2===0 ? -3 : 4);
    const fillId = (l%3===0) ? 'petalA' : ((l%3===1) ? 'petalB' : 'petalC');
    for(let p=0; p<petals; p++){
      const a = (360/petals) * p + R(-12,12);
      const pet = C('path');
      // create an organic petal path using bezier
      const tipX = 0;
      const tipY = -layerR;
      const w = width * (1 + R(-0.12,0.12));
      const c1x = -w*0.5 * (0.3 + R(-0.05,0.15));
      const c1y = -layerR * (0.35 + R(-0.05,0.06));
      const c2x = w*0.5 * (0.3 + R(-0.05,0.15));
      const c2y = -layerR * (0.55 + R(-0.05,0.12));
      const d = `M ${-w*0.5} 0 C ${c1x} ${c1y} ${c2x} ${c2y} ${tipX} ${tipY} C ${-c2x} ${c2y} ${-c1x} ${c1y} ${w*0.5} 0 Z`;
      pet.setAttribute('d', d);
      pet.setAttribute('fill', `url(#${fillId})`);
      pet.setAttribute('transform', `rotate(${a}) translate(${R(-1.8,1.8)} ${R(-1.6,1.6)})`);
      pet.setAttribute('opacity', 0.95 - (l*0.03));
      // slight inner highlight
      if(rnd() > 0.85){
        pet.setAttribute('style','mix-blend-mode:screen');
      }
      g.appendChild(pet);
    }
  }
  // center disk
  const center = C('circle');
  center.setAttribute('cx', 0);
  center.setAttribute('cy', 0);
  center.setAttribute('r', 6 + R(-1.2,1.2));
  center.setAttribute('fill','url(#centerG)');
  center.setAttribute('filter','url(#softShadow)');
  g.appendChild(center);

  return g;
}

// Arrange many roses in tight circular bouquet (top view slightly angled)
function composeBouquet(){
  const bouquet = C('g');
  bouquet.setAttribute('transform','translate(550 260) scale(1)'); // center position

  // create a spiral distribution for a tight round bouquet (like the photo)
  const total = 23; // target number of roses (photo had ~20-25)
  const rings = [
    {r: 0, count:1},
    {r: 36, count:6},
    {r: 78, count:7},
    {r: 120, count:7},
    {r: 160, count:2}
  ];

  // jitter to avoid mechanical grid
  let idx = 0;
  rings.forEach((ring,ringIndex) => {
    for(let i=0;i<ring.count;i++){
      const angle = (360 / ring.count) * i + R(-12,12);
      const rad = ring.r * (1 + R(-0.08,0.08));
      // convert polar to cartesian (rotate to create slight oval)
      const x = Math.cos((angle) * Math.PI/180) * rad * (1 + ringIndex*0.01) + R(-6,6);
      const y = Math.sin((angle) * Math.PI/180) * rad * (0.86 + R(-0.04,0.04)) + R(-8,8) - ringIndex*6;
      const s = 0.9 + R(-0.08,0.14) - ringIndex*0.01;
      const rot = R(-20,20);
      const variant = RI(0,2);
      const rose = makeRose(x, y, s, rot, variant);
      bouquet.appendChild(rose);
      idx++;
    }
  });

  // Add a couple of accent small buds on the side for realism
  for(let b=0;b<3;b++){
    const bx = R(-170,170);
    const by = R(140,220);
    const bud = makeRose(bx, by, R(0.45,0.75), R(-30,30), RI(0,2));
    bud.setAttribute('opacity', 0.95);
    bouquet.appendChild(bud);
  }

  // front tie highlight (small oval)
  const tieHighlight = C('ellipse');
  tieHighlight.setAttribute('cx', 52);
  tieHighlight.setAttribute('cy', 420);
  tieHighlight.setAttribute('rx', 100);
  tieHighlight.setAttribute('ry', 22);
  tieHighlight.setAttribute('fill', 'rgba(0,0,0,0.06)');
  tieHighlight.setAttribute('transform', 'translate(0 0)');
  bouquet.appendChild(tieHighlight);

  return bouquet;
}

// Put everything together
drawBow();
root.appendChild(composeBouquet());

// subtle vignette to frame composition
const vignette = C('rect');
vignette.setAttribute('x',0); vignette.setAttribute('y',0);
vignette.setAttribute('width',1100); vignette.setAttribute('height',820);
vignette.setAttribute('fill','url(#paperG)');
vignette.setAttribute('opacity',0);
svg.appendChild(vignette);

// Very light gentle animation: tiny breathing (no heavy motion)
let t0 = performance.now();
function animate(){
  const t = (performance.now() - t0)/1000;
  const sway = Math.sin(t*0.6) * 0.6;
  root.setAttribute('transform', `translate(0 ${Math.sin(t*0.8)*1.2}) rotate(${sway} 550 360)`);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

// Copy link button: includes msg and seed for exact reproduction
document.getElementById('copyLink').addEventListener('click', async ()=>{
  const origin = location.origin + location.pathname;
  const link = `${origin}?msg=${encodeURIComponent(document.getElementById('phrase').textContent)}&seed=${seed}`;
  try{
    await navigator.clipboard.writeText(link);
    const b = document.getElementById('copyLink');
    const old = b.textContent;
    b.textContent = 'Link copiado ✅';
    setTimeout(()=> b.textContent = old, 1800);
  }catch(e){
    alert('No pude copiar el link. Podés copiar manualmente:\n' + link);
  }
});

</script>
</body>
</html>


